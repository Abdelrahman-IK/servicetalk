<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>BufferStrategies</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="BufferStrategies";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.servicetalk.concurrent.api</a></div>
<h2 title="Class BufferStrategies" class="title">Class BufferStrategies</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.servicetalk.concurrent.api.BufferStrategies</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public final class <span class="typeNameLabel">BufferStrategies</span>
extends java.lang.Object</pre>
<div class="block">A static factory of <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> instances.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;java.lang.Iterable&lt;T&gt;&gt;,&#8203;java.lang.Iterable&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forCountOrTime(int,java.time.Duration)">forCountOrTime</a></span>&#8203;(int&nbsp;count,
              java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;java.lang.Iterable&lt;T&gt;&gt;,&#8203;java.lang.Iterable&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forCountOrTime(int,java.time.Duration,io.servicetalk.concurrent.api.Executor)">forCountOrTime</a></span>&#8203;(int&nbsp;count,
              java.time.Duration&nbsp;duration,
              <a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static &lt;T,&#8203;BC extends <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;<br><a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forCountOrTime(int,java.time.Duration,java.util.function.Supplier)">forCountOrTime</a></span>&#8203;(int&nbsp;count,
              java.time.Duration&nbsp;duration,
              java.util.function.Supplier&lt;BC&gt;&nbsp;accumulatorSupplier)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static &lt;T,&#8203;BC extends <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;<br><a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forCountOrTime(int,java.time.Duration,java.util.function.Supplier,io.servicetalk.concurrent.api.Executor)">forCountOrTime</a></span>&#8203;(int&nbsp;count,
              java.time.Duration&nbsp;duration,
              java.util.function.Supplier&lt;BC&gt;&nbsp;accumulatorSupplier,
              <a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="forCountOrTime(int,java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forCountOrTime</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;java.lang.Iterable&lt;T&gt;&gt;,&#8203;java.lang.Iterable&lt;T&gt;&gt;&nbsp;forCountOrTime&#8203;(int&nbsp;count,
                                                                                                                                               java.time.Duration&nbsp;duration)</pre>
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the
 returned <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> will have exactly <code>count</code> number of items. The emitted buffers may have
 less or more items than the <code>count</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items added to the buffer.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>count</code> - Number of items to add before closing the current buffer boundary, if not already closed. The
 emitted buffers may have less or more items than this <code>count</code>.</dd>
<dd><code>duration</code> - <code>Duration</code> after which the current buffer boundary is closed, if not already closed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</dd>
</dl>
</li>
</ul>
<a id="forCountOrTime(int,java.time.Duration,io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forCountOrTime</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;java.lang.Iterable&lt;T&gt;&gt;,&#8203;java.lang.Iterable&lt;T&gt;&gt;&nbsp;forCountOrTime&#8203;(int&nbsp;count,
                                                                                                                                               java.time.Duration&nbsp;duration,
                                                                                                                                               <a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the
 returned <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> will have exactly <code>count</code> number of items. The emitted buffers may have
 less or more items than the <code>count</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items added to the buffer.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>count</code> - Number of items to add before closing the current buffer boundary, if not already closed.</dd>
<dd><code>duration</code> - <code>Duration</code> after which the current buffer boundary is closed, if not already closed.</dd>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for recording the passed <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</dd>
</dl>
</li>
</ul>
<a id="forCountOrTime(int,java.time.Duration,java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forCountOrTime</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;BC extends <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;&nbsp;<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;&nbsp;forCountOrTime&#8203;(int&nbsp;count,
                                                                                                                                                                      java.time.Duration&nbsp;duration,
                                                                                                                                                                      java.util.function.Supplier&lt;BC&gt;&nbsp;accumulatorSupplier)</pre>
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the
 returned <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> will have exactly <code>count</code> number of items. The emitted buffers may have
 less or more items than the <code>count</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items added to the buffer.</dd>
<dd><code>BC</code> - Type of <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> used to accumulate items in a buffer.</dd>
<dd><code>B</code> - Type of object created after an <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> is <a href="BufferStrategy.Accumulator.html#finish()"><code>finished</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>count</code> - Number of items to add before closing the current buffer boundary, if not already closed.</dd>
<dd><code>duration</code> - <code>Duration</code> after which the current buffer boundary is closed, if not already closed.</dd>
<dd><code>accumulatorSupplier</code> - A <code>Supplier</code> of <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> every time a buffer boundary is closed.
 Methods on the <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> returned from this <code>Supplier</code> may or may not be called.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</dd>
</dl>
</li>
</ul>
<a id="forCountOrTime(int,java.time.Duration,java.util.function.Supplier,io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>forCountOrTime</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;BC extends <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;&nbsp;<a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy</a>&lt;T,&#8203;<a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api">BufferStrategy.Accumulator</a>&lt;T,&#8203;B&gt;,&#8203;B&gt;&nbsp;forCountOrTime&#8203;(int&nbsp;count,
                                                                                                                                                                      java.time.Duration&nbsp;duration,
                                                                                                                                                                      java.util.function.Supplier&lt;BC&gt;&nbsp;accumulatorSupplier,
                                                                                                                                                                      <a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Returns a <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the
 returned <a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> will have exactly <code>count</code> number of items. The emitted buffers may have
 less or more items than the <code>count</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of items added to the buffer.</dd>
<dd><code>BC</code> - Type of <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> used to accumulate items in a buffer.</dd>
<dd><code>B</code> - Type of object created after an <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> is <a href="BufferStrategy.Accumulator.html#finish()"><code>finished</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>count</code> - Number of items to add before closing the current buffer boundary, if not already closed.</dd>
<dd><code>duration</code> - <code>Duration</code> after which the current buffer boundary is closed, if not already closed.</dd>
<dd><code>accumulatorSupplier</code> - A <code>Supplier</code> of <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> every time a buffer boundary is closed.
 Methods on the <a href="BufferStrategy.Accumulator.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy.Accumulator</code></a> returned from this <code>Supplier</code> may or may not be called.</dd>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for recording the passed <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="BufferStrategy.html" title="interface in io.servicetalk.concurrent.api"><code>BufferStrategy</code></a> that creates buffer boundaries based on number of items buffered or time elapsed
 since the current buffer boundary started.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
