<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Completable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Completable";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":9,"i8":9,"i9":10,"i10":9,"i11":9,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":9,"i20":10,"i21":10,"i22":10,"i23":10,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":6,"i30":42,"i31":42,"i32":42,"i33":42,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":10,"i49":10,"i50":10,"i51":10,"i52":9,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":42,"i63":42,"i64":10,"i65":42,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":42,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.servicetalk.concurrent.api</a></div>
<h2 title="Class Completable" class="title">Class Completable</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.servicetalk.concurrent.api.Completable</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="LegacyTestCompletable.html" title="class in io.servicetalk.concurrent.api">LegacyTestCompletable</a></code>, <code><a href="RunnableCompletable.html" title="class in io.servicetalk.concurrent.api">RunnableCompletable</a></code>, <code><a href="internal/SubscribableCompletable.html" title="class in io.servicetalk.concurrent.api.internal">SubscribableCompletable</a></code>, <code><a href="TestCompletable.html" title="class in io.servicetalk.concurrent.api">TestCompletable</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">Completable</span>
extends java.lang.Object</pre>
<div class="block">An asynchronous computation that does not emit any data. It just completes or emits an error.

 <h2>How to subscribe?</h2>

 This class does not provide a way to subscribe using a <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> as such calls are
 ambiguous about the intent whether the subscribe is part of the same source (a.k.a an operator) or it is a terminal
 subscribe. If it is required to subscribe to a source, then a <a href="SourceAdapters.html" title="class in io.servicetalk.concurrent.api"><code>source adapter</code></a> can be used to
 convert to a <a href="../CompletableSource.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource</code></a>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colSecond" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">Completable</a></span>()</code></th>
<td class="colLast">
<div class="block">New instance.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterCancel(java.lang.Runnable)">afterCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">afterFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 
     <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterFinally(java.lang.Runnable)">afterFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 
     <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>
     <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnComplete(java.lang.Runnable)">afterOnComplete</a></span>&#8203;(java.lang.Runnable&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>after</strong> <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>
 is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnError(java.util.function.Consumer)">afterOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterOnSubscribe(java.util.function.Consumer)">afterOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#afterSubscriber(java.util.function.Supplier)">afterSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to
 subscribe and invokes all the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#amb(io.servicetalk.concurrent.api.Completable...)">amb</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#amb(java.lang.Iterable)">amb</a></span>&#8203;(java.lang.Iterable&lt;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ambWith(io.servicetalk.concurrent.api.Completable)">ambWith</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of either this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or the passed <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, whichever terminates first.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#anyOf(io.servicetalk.concurrent.api.Completable...)">anyOf</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#anyOf(java.lang.Iterable)">anyOf</a></span>&#8203;(java.lang.Iterable&lt;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeCancel(java.lang.Runnable)">beforeCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">beforeFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 
     <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeFinally(java.lang.Runnable)">beforeFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 
     <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>
     <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnComplete(java.lang.Runnable)">beforeOnComplete</a></span>&#8203;(java.lang.Runnable&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>before</strong> <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>
 is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnError(java.util.function.Consumer)">beforeOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeOnSubscribe(java.util.function.Consumer)">beforeOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#beforeSubscriber(java.util.function.Supplier)">beforeSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to
 subscribe and invokes all the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completed()">completed</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a realized completed <code>Completable</code>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Completable)">concat</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 and propagate its terminal signal to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Completable...)">concat</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;nexts)</code></th>
<td class="colLast">
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to each <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> in <code>nexts</code>
 in a sequential fashion after termination, and the final terminal signals is propagated to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Publisher)">concat</a></span>&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 and propagate all emissions to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#concat(io.servicetalk.concurrent.api.Single)">concat</a></span>&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 and propagate the result to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#defer(java.util.function.Supplier)">defer</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completableSupplier)</code></th>
<td class="colLast">
<div class="block">Defer creation of a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> till it is subscribed to.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#failed(java.lang.Throwable)">failed</a></span>&#8203;(java.lang.Throwable&nbsp;cause)</code></th>
<td class="colLast">
<div class="block">Creates a realized failed <code>Completable</code>.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromFuture(java.util.concurrent.Future)">fromFuture</a></span>&#8203;(java.util.concurrent.Future&lt;?&gt;&nbsp;future)</code></th>
<td class="colLast">
<div class="block">Convert from a <code>Future</code> to a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> via <code>Future.get()</code>.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromRunnable(java.lang.Runnable)">fromRunnable</a></span>&#8203;(java.lang.Runnable&nbsp;runnable)</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which when subscribed will invoke <code>Runnable.run()</code> on the passed
 <code>Runnable</code> and emit the value returned by that invocation from the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fromStage(java.util.concurrent.CompletionStage)">fromStage</a></span>&#8203;(java.util.concurrent.CompletionStage&lt;?&gt;&nbsp;stage)</code></th>
<td class="colLast">
<div class="block">Convert from a <code>CompletionStage</code> to a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)">handleSubscribe</a></span>&#8203;(<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">Handles a subscriber to this <code>Completable</code>.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(long,java.util.concurrent.TimeUnit)">idleTimeout</a></span>&#8203;(long&nbsp;duration,
           java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(long,java.util.concurrent.TimeUnit)"><code>timeout(long, TimeUnit)</code></a>.</div>
</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">idleTimeout</a></span>&#8203;(long&nbsp;duration,
           java.util.concurrent.TimeUnit&nbsp;unit,
           <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)"><code>timeout(long, TimeUnit, io.servicetalk.concurrent.Executor)</code></a>.</div>
</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(java.time.Duration)">idleTimeout</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(java.time.Duration)"><code>timeout(Duration)</code></a>.</div>
</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idleTimeout(java.time.Duration,io.servicetalk.concurrent.Executor)">idleTimeout</a></span>&#8203;(java.time.Duration&nbsp;duration,
           <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(java.time.Duration,io.servicetalk.concurrent.Executor)"><code>timeout(Duration, io.servicetalk.concurrent.Executor)</code></a>.</div>
</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftAsync(io.servicetalk.concurrent.api.CompletableOperator)">liftAsync</a></span>&#8203;(<a href="CompletableOperator.html" title="interface in io.servicetalk.concurrent.api">CompletableOperator</a>&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liftSync(io.servicetalk.concurrent.api.CompletableOperator)">liftSync</a></span>&#8203;(<a href="CompletableOperator.html" title="interface in io.servicetalk.concurrent.api">CompletableOperator</a>&nbsp;operator)</code></th>
<td class="colLast">
<div class="block"><strong>This method requires advanced knowledge of building operators.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#merge(io.servicetalk.concurrent.api.Completable)">merge</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> so that the resulting
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully when both of these complete or either terminates with an error.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#merge(io.servicetalk.concurrent.api.Completable...)">merge</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s so that the resulting
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully when all of these complete or any one terminates with an error.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#merge(io.servicetalk.concurrent.api.Publisher)">merge</a></span>&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&nbsp;mergeWith)</code></th>
<td class="colLast">
<div class="block">Merges the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#merge(java.lang.Iterable)">merge</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s so that the resulting
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully when all of these complete or terminates with an error when any one
 terminates with an error.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAll(int,io.servicetalk.concurrent.api.Completable...)">mergeAll</a></span>&#8203;(int&nbsp;maxConcurrency,
        <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAll(io.servicetalk.concurrent.api.Completable...)">mergeAll</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAll(java.lang.Iterable)">mergeAll</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAll(java.lang.Iterable,int)">mergeAll</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables,
        int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAllDelayError(int,io.servicetalk.concurrent.api.Completable...)">mergeAllDelayError</a></span>&#8203;(int&nbsp;maxConcurrency,
                  <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAllDelayError(io.servicetalk.concurrent.api.Completable...)">mergeAllDelayError</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAllDelayError(java.lang.Iterable)">mergeAllDelayError</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeAllDelayError(java.lang.Iterable,int)">mergeAllDelayError</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables,
                  int&nbsp;maxConcurrency)</code></th>
<td class="colLast">
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeDelayError(io.servicetalk.concurrent.api.Completable)">mergeDelayError</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, and delays error notification until
 all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeDelayError(io.servicetalk.concurrent.api.Completable...)">mergeDelayError</a></span>&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, and delays error notification until
 all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeDelayError(io.servicetalk.concurrent.api.Publisher)">mergeDelayError</a></span>&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&nbsp;mergeWith)</code></th>
<td class="colLast">
<div class="block">Merges the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeDelayError(java.lang.Iterable)">mergeDelayError</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;other)</code></th>
<td class="colLast">
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, and delays error notification until
 all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#never()">never</a></span>()</code></th>
<td class="colLast">
<div class="block">Creates a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that never terminates.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorComplete()">onErrorComplete</a></span>()</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal
 (e.g.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorComplete(java.lang.Class)">onErrorComplete</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>type</code> into a
 <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal (e.g.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorComplete(java.util.function.Predicate)">onErrorComplete</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>predicate</code> into a
 <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal (e.g.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.lang.Class,java.util.function.Function)">onErrorMap</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
          java.util.function.Function&lt;? super E,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>type</code> into a different error.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.util.function.Function)">onErrorMap</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a different error.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorMap(java.util.function.Predicate,java.util.function.Function)">onErrorMap</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
          java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>predicate</code> into a different error.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.lang.Class,java.util.function.Function)">onErrorResume</a></span>&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
             java.util.function.Function&lt;? super E,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from errors emitted by this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>type</code> by using another
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.util.function.Function)">onErrorResume</a></span>&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from any error emitted by this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> by using another <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the
 passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onErrorResume(java.util.function.Predicate,java.util.function.Function)">onErrorResume</a></span>&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
             java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;nextFactory)</code></th>
<td class="colLast">
<div class="block">Recover from errors emitted by this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>predicate</code> by using another
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the passed <code>nextFactory</code>.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)">publishAndSubscribeOn</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This operator has been deprecated because of upcoming behavior changes in how offloading via
 operators is done.</div>
</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishAndSubscribeOnOverride(io.servicetalk.concurrent.api.Executor)">publishAndSubscribeOnOverride</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This method will be removed in a future release.</div>
</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOn(io.servicetalk.concurrent.api.Executor)">publishOn</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>
 methods.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#publishOnOverride(io.servicetalk.concurrent.api.Executor)">publishOnOverride</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This method will be removed in a future release.</div>
</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Void&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeat(java.util.function.IntPredicate)">repeat</a></span>&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> when it completes and the passed <code>IntPredicate</code> returns
 <code>true</code>.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code><a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Void&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#repeatWhen(java.util.function.IntFunction)">repeatWhen</a></span>&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retry(io.servicetalk.concurrent.api.BiIntPredicate)">retry</a></span>&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">retryWhen</a></span>&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</code></th>
<td class="colLast">
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the
 supplied <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribe()">subscribe</a></span>()</code></th>
<td class="colLast">
<div class="block">Subscribe to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and log any <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a>.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribe(java.lang.Runnable)">subscribe</a></span>&#8203;(java.lang.Runnable&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Subscribe to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and log any <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a>.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeInternal(io.servicetalk.concurrent.CompletableSource.Subscriber)">subscribeInternal</a></span>&#8203;(<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&nbsp;subscriber)</code></th>
<td class="colLast">
<div class="block">A internal subscribe method similar to <a href="../CompletableSource.html#subscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>CompletableSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)">subscribeOn</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 
     All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.
     The <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> method.
 
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeOnOverride(io.servicetalk.concurrent.api.Executor)">subscribeOnOverride</a></span>&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This method will be removed in a future release.</div>
</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#subscribeShareContext()">subscribeShareContext</a></span>()</code></th>
<td class="colLast">
<div class="block">Signifies that when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a>.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(long,java.util.concurrent.TimeUnit)">timeout</a></span>&#8203;(long&nbsp;duration,
       java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">timeout</a></span>&#8203;(long&nbsp;duration,
       java.util.concurrent.TimeUnit&nbsp;unit,
       <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(java.time.Duration)">timeout</a></span>&#8203;(java.time.Duration&nbsp;duration)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#timeout(java.time.Duration,io.servicetalk.concurrent.Executor)">timeout</a></span>&#8203;(java.time.Duration&nbsp;duration,
       <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>java.util.concurrent.CompletionStage&lt;java.lang.Void&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toCompletionStage()">toCompletionStage</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this <code>Completable</code> to a <code>CompletionStage</code>.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.Future&lt;java.lang.Void&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toFuture()">toFuture</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this <code>Completable</code> to a <code>Future</code>.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toPublisher()">toPublisher</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this <code>Completable</code> to a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code><a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.lang.Void&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toSingle()">toSingle</a></span>()</code></th>
<td class="colLast">
<div class="block">Converts this <code>Completable</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenCancel(java.lang.Runnable)">whenCancel</a></span>&#8203;(java.lang.Runnable&nbsp;onCancel)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">whenFinally</a></span>&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any of the
 following terminal methods are called:
 
     <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a>
     <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a>
 
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenFinally(java.lang.Runnable)">whenFinally</a></span>&#8203;(java.lang.Runnable&nbsp;doFinally)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 
     <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>
     <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a>
     <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a>
 
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnComplete(java.lang.Runnable)">whenOnComplete</a></span>&#8203;(java.lang.Runnable&nbsp;onComplete)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument when <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnError(java.util.function.Consumer)">whenOnError</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenOnSubscribe(java.util.function.Consumer)">whenOnSubscribe</a></span>&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</code></th>
<td class="colLast">
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code><a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whenSubscriber(java.util.function.Supplier)">whenSubscriber</a></span>&#8203;(java.util.function.Supplier&lt;? extends <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&gt;&nbsp;subscriberSupplier)</code></th>
<td class="colLast">
<div class="block">Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> when the corresponding methods are called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of
 the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Completable</h4>
<pre>protected&nbsp;Completable()</pre>
<div class="block">New instance.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="onErrorComplete()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorComplete()</pre>
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal
 (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         // ignored
     }
 </code></pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a
 <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorComplete(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorComplete&#8203;(java.lang.Class&lt;E&gt;&nbsp;type)</pre>
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>type</code> into a
 <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         if (!type.isInstance(cause)) {
           throw cause;
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The <code>Throwable</code> type.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>type</code>
 into a <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorComplete(java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorComplete&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate)</pre>
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>predicate</code> into a
 <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         if (!predicate.test(cause)) {
           throw cause;
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed to and
 <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal. Returns <code>false</code> to propagate the error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match
 <code>predicate</code> into a <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> signal (e.g. swallows the error).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorMap&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         throw mapper.apply(cause);
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorMap&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                    java.util.function.Function&lt;? super E,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>type</code> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         if (type.isInstance(cause)) {
           throw mapper.apply(cause);
         } else {
           throw cause;
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorMap(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorMap&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                    java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>predicate</code> into a different error.
 <p>
 This method provides a data transformation in sequential programming similar to:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         if (predicate.test(cause)) {
           throw mapper.apply(cause);
         } else {
           throw cause;
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed via <code>mapper</code>. Returns
 <code>false</code> to propagate the original error.</dd>
<dd><code>mapper</code> - returns the error used to terminate the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which transform errors emitted on this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> into a different error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorResume&#8203;(java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from any error emitted by this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> by using another <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the
 passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         // Note that nextFactory returning a error Completable is like re-throwing (nextFactory shouldn't throw).
         nextFactory.apply(cause);
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextFactory</code> - Returns the next <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, if this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that recovers from an error from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> by using another
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the passed <code>nextFactory</code>.</dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorResume&#8203;(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                       java.util.function.Function&lt;? super E,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from errors emitted by this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>type</code> by using another
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         if (type.isInstance(cause)) {
           // Note nextFactory returning a error Completable is like re-throwing (nextFactory shouldn't throw).
           results = nextFactory.apply(cause);
         } else {
           throw cause;
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>E</code> - The type of <code>Throwable</code> to transform.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The <code>Throwable</code> type to filter, operator will not apply for errors which don't match this type.</dd>
<dd><code>nextFactory</code> - Returns the next <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that recovers from an error from this <code>Publisher</code> by using another
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the passed <code>nextFactory</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="onErrorResume(java.util.function.Predicate,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;onErrorResume&#8203;(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                       java.util.function.Function&lt;? super java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;nextFactory)</pre>
<div class="block">Recover from errors emitted by this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which match <code>predicate</code> by using another
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the passed <code>nextFactory</code>.
 <p>
 This method provides similar capabilities to a try/catch block in sequential programming:
 <pre><code>
     try {
         resultOfThisCompletable();
     } catch (Throwable cause) {
         if (predicate.test(cause)) {
           // Note that nextFactory returning a error Publisher is like re-throwing (nextFactory shouldn't throw).
           results = nextFactory.apply(cause);
         } else {
           throw cause;
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>predicate</code> - returns <code>true</code> if the <code>Throwable</code> should be transformed via <code>nextFactory</code>.
 Returns <code>false</code> to propagate the original error.</dd>
<dd><code>nextFactory</code> - Returns the next <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that recovers from an error from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> by using another
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> provided by the passed <code>nextFactory</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX catch operator.</a></dd>
</dl>
</li>
</ul>
<a id="whenOnComplete(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;whenOnComplete&#8203;(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument when <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The order in which <code>onComplete</code> will be invoked relative to <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> is
 undefined. If you need strict ordering see <a href="#beforeOnComplete(java.lang.Runnable)"><code>beforeOnComplete(Runnable)</code></a> and
 <a href="#afterOnComplete(java.lang.Runnable)"><code>afterOnComplete(Runnable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(result);
  onComplete.run();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onComplete</code> - Invoked when <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnComplete(java.lang.Runnable)"><code>beforeOnComplete(Runnable)</code></a>, 
<a href="#afterOnComplete(java.lang.Runnable)"><code>afterOnComplete(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;whenOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument when <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The order in which <code>onError</code> will be invoked relative to <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is
 undefined. If you need strict ordering see <a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a> and
 <a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    resultOfThisCompletable();
  } catch (Throwable cause) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked when <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnError(java.util.function.Consumer)"><code>beforeOnError(Consumer)</code></a>, 
<a href="#afterOnError(java.util.function.Consumer)"><code>afterOnError(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;whenFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument exactly once, when any of the following terminal
 methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a> and <a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      resultOfThisCompletable();
  } finally {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked exactly once, when any of the following terminal methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(java.lang.Runnable)"><code>beforeFinally(Runnable)</code></a>, 
<a href="#afterFinally(java.lang.Runnable)"><code>afterFinally(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;whenFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>whenFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument when any of the
 following terminal methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to the above methods is undefined. If you need
 strict ordering see <a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a> and
 <a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      resultOfThisCompletable();
  } catch(Throwable t) {
      // NOTE: The order of operations here is not guaranteed by this method!
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  // NOTE: The order of operations here is not guaranteed by this method!
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>beforeFinally(TerminalSignalConsumer)</code></a>, 
<a href="#afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)"><code>afterFinally(TerminalSignalConsumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="whenCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;whenCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for
 Subscriptions of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The order in which <code>whenFinally</code> will be invoked relative to <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is undefined. If
 you need strict ordering see <a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a> and <a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked when <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeCancel(java.lang.Runnable)"><code>beforeCancel(Runnable)</code></a>, 
<a href="#afterCancel(java.lang.Runnable)"><code>afterCancel(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;idleTimeout&#8203;(long&nbsp;duration,
                                     java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(long,java.util.concurrent.TimeUnit)"><code>timeout(long, TimeUnit)</code></a>.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;idleTimeout&#8203;(long&nbsp;duration,
                                     java.util.concurrent.TimeUnit&nbsp;unit,
                                     <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)"><code>timeout(long, TimeUnit, io.servicetalk.concurrent.Executor)</code></a>.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for managing the timer notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;idleTimeout&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(java.time.Duration)"><code>timeout(Duration)</code></a>.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="idleTimeout(java.time.Duration,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idleTimeout</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;idleTimeout&#8203;(java.time.Duration&nbsp;duration,
                                     <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use <a href="#timeout(java.time.Duration,io.servicetalk.concurrent.Executor)"><code>timeout(Duration, io.servicetalk.concurrent.Executor)</code></a>.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for managing the timer notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;timeout&#8203;(long&nbsp;duration,
                                 java.util.concurrent.TimeUnit&nbsp;unit)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(long,java.util.concurrent.TimeUnit,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;timeout&#8203;(long&nbsp;duration,
                                 java.util.concurrent.TimeUnit&nbsp;unit,
                                 <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dd><code>unit</code> - The units for <code>duration</code>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for managing the timer notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(java.time.Duration)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;timeout&#8203;(java.time.Duration&nbsp;duration)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="timeout(java.time.Duration,io.servicetalk.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;timeout&#8203;(java.time.Duration&nbsp;duration,
                                 <a href="../Executor.html" title="interface in io.servicetalk.concurrent">Executor</a>&nbsp;timeoutExecutor)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate
 with a <code>TimeoutException</code> if time <code>duration</code> elapses between subscribe and termination.
 The timer starts when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed.
 <p>
 In the event of timeout any <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> from <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> will be
 <a href="../Cancellable.html#cancel()"><code>cancelled</code></a> and the associated <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> will be
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>terminated</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>duration</code> - The time duration which is allowed to elapse before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dd><code>timeoutExecutor</code> - The <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use for managing the timer notifications.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will mimic the signals of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> but will terminate with
 a <code>TimeoutException</code> if time <code>duration</code> elapses before <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX timeout operator.</a></dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;concat&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;next)</pre>
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 and propagate its terminal signal to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. Any error from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 or <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> are propagated to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     resultOfThisCompletable();
     nextCompletable();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> to subscribe after this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that emits the terminal signal of <code>next</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, after this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> has terminated successfully.</dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;concat&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;nexts)</pre>
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to each <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> in <code>nexts</code>
 in a sequential fashion after termination, and the final terminal signals is propagated to the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. Any error from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or from <code>nexts</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> are
 propagated to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 This method provide equivalent functionality as:
 <pre><code>
   Completable original = ...;
   Completable[] nexts  = ...;
   Completable result = original;
   for (int i = 0; i &lt; nexts.length; ++i) {
       result = result.concat(nexts[i]);
   }
   return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nexts</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to subscribe after this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that emits the terminal signal of <code>nexts</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, after this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> has terminated successfully.</dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Single)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;&lt;T&gt;&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;T&gt;&nbsp;concat&#8203;(<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;? extends T&gt;&nbsp;next)</pre>
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 and propagate the result to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>. Any error from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or <code>next</code>
 <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> are propagated to the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     resultOfThisCompletable();
     T result = resultOfNextSingle();
     return result;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of result of the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> to subscribe after this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that emits the result of <code>next</code> <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, after this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>
 has terminated successfully.</dd>
</dl>
</li>
</ul>
<a id="concat(io.servicetalk.concurrent.api.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre class="methodSignature">public final&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;concat&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&nbsp;next)</pre>
<div class="block">Once this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is terminated successfully, subscribe to <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>
 and propagate all emissions to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Any error from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or
 <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> are propagated to the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 This method provides a means to sequence the execution of two asynchronous sources and in sequential programming
 is similar to:
 <pre><code>
     List&lt;T&gt; results = new ...;
     resultOfThisCompletable();
     results.addAll(nextStream());
     return results;
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - Type of objects emitted from the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>next</code> - <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to subscribe after this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items emitted from <code>next</code> <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>, after this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> has terminated successfully.</dd>
</dl>
</li>
</ul>
<a id="merge(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;merge&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;other)</pre>
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> so that the resulting
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully when both of these complete or either terminates with an error.
 <p>
 This method provides a means to merge multiple asynchronous sources, fails-fast in the presence of any errors,
 and in sequential programming is similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...;
     futures.add(e.submit(() -&gt; resultOfThisCompletable()));
     futures.add(e.submit(() -&gt; resultOfCompletable(other));
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;Void&gt; future : futures) {
         future.get(); // Throws if the processing for this item failed.
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to merge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully when this and <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s
 complete or terminates with an error when either terminates with an error.</dd>
</dl>
</li>
</ul>
<a id="merge(io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;merge&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;other)</pre>
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s so that the resulting
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully when all of these complete or any one terminates with an error.
 <p>
 This method provides a means to merge multiple asynchronous sources, fails-fast in the presence of any errors,
 and in sequential programming is similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...;
     futures.add(e.submit(() -&gt; resultOfThisCompletable()));
     for (Completable c : other) {
         futures.add(e.submit(() -&gt; resultOfCompletable(c));
     }
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;Void&gt; future : futures) {
         future.get(); // Throws if the processing for this item failed.
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to merge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully when this and all <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s
 complete or terminates with an error when any one terminates with an error.</dd>
</dl>
</li>
</ul>
<a id="merge(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;merge&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;other)</pre>
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s so that the resulting
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully when all of these complete or terminates with an error when any one
 terminates with an error.
 <p>
 This method provides a means to merge multiple asynchronous sources, fails-fast in the presence of any errors,
 and in sequential programming is similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...;
     futures.add(e.submit(() -&gt; resultOfThisCompletable()));
     for (Completable c : other) {
         futures.add(e.submit(() -&gt; resultOfCompletable(c));
     }
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;Void&gt; future : futures) {
         future.get(); // Throws if the processing for this item failed.
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to merge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully when this and all <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s
 complete or terminates with an error when any one terminates with an error.</dd>
</dl>
</li>
</ul>
<a id="merge(io.servicetalk.concurrent.api.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre class="methodSignature">public final&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;merge&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&nbsp;mergeWith)</pre>
<div class="block">Merges the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The resulting <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits all items emitted by the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and terminates
 successfully when both this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates successfully.
 It terminates with an error when any one of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates with
 an error.
 <pre><code>
     ExecutorService e = ...;
     Future&lt;?&gt; future1 = e.submit(() -&gt; resultOfThisCompletable()));
     Future&lt;?&gt; future2 = e.submit(() -&gt; resultOfMergeWithStream());
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     future1.get(); // Throws if this Completable failed.
     future2.get(); // Throws if mergeWith Publisher failed.
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The value type of the resulting <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mergeWith</code> - the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to merge in</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits all items emitted by the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and terminates
 successfully when both this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates successfully.
 It terminates with an error when any one of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminates with
 an error.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a></dd>
</dl>
</li>
</ul>
<a id="mergeDelayError(io.servicetalk.concurrent.api.Publisher)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeDelayError</h4>
<pre class="methodSignature">public final&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;mergeDelayError&#8203;(<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;? extends T&gt;&nbsp;mergeWith)</pre>
<div class="block">Merges the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> with this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The resulting <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits all items emitted by the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and terminates when both
 this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminate. If either terminates with an error then the
 error will be propagated to the return value.
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...;
     futures.add(e.submit(() -&gt; resultOfThisCompletable()));
     futures.add(e.submit(() -&gt; resultOfMergeWithStream());
     Throwable overallCause = null;
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;Void&gt; future : futures) {
         try {
             f.get();
         } catch (Throwable cause) {
             if (overallCause != null) {
                 overallCause = cause;
             }
         }
     }
     if (overallCause != null) {
         throw overallCause;
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The value type of the resulting <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mergeWith</code> - the <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> to merge in</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> emits all items emitted by the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> and terminates when both this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and the passed <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> terminate. If either terminates with an error then the
 error will be propagated to the return value.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX merge operator.</a></dd>
</dl>
</li>
</ul>
<a id="mergeDelayError(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeDelayError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeDelayError&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;other)</pre>
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, and delays error notification until
 all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate.
 <p>
 Use <a href="#merge(io.servicetalk.concurrent.api.Completable)"><code>merge(Completable)</code></a> if any error should immediately terminate the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 This method provides a means to merge multiple asynchronous sources, delays throwing in the presence of any
 errors, and in sequential programming is similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...;
     futures.add(e.submit(() -&gt; resultOfThisCompletable()));
     futures.add(e.submit(() -&gt; resultOfCompletable(other));
     Throwable overallCause = null;
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;Void&gt; future : futures) {
         try {
             f.get();
         } catch (Throwable cause) {
             if (overallCause != null) {
                 overallCause = cause;
             }
         }
     }
     if (overallCause != null) {
         throw overallCause;
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> to merge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates after <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and <code>other</code>
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. If all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate successfully then the return value will
 terminate successfully. If any <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates in an error, then the return value will also
 terminate in an error.</dd>
</dl>
</li>
</ul>
<a id="mergeDelayError(io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeDelayError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeDelayError&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;other)</pre>
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, and delays error notification until
 all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate.
 <p>
 Use <a href="#merge(io.servicetalk.concurrent.api.Completable...)"><code>merge(Completable...)</code></a> if any error should immediately terminate the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 This method provides a means to merge multiple asynchronous sources, delays throwing in the presence of any
 errors, and in sequential programming is similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...;
     futures.add(e.submit(() -&gt; resultOfThisCompletable()));
     for (Completable c : other) {
         futures.add(e.submit(() -&gt; resultOfCompletable(c));
     }
     Throwable overallCause = null;
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;Void&gt; future : futures) {
         try {
             f.get();
         } catch (Throwable cause) {
             if (overallCause != null) {
                 overallCause = cause;
             }
         }
     }
     if (overallCause != null) {
         throw overallCause;
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to merge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates after <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and all <code>other</code>
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s. If all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate successfully then the return value will
 terminate successfully. If any <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates in an error, then the return value will also
 terminate in an error.</dd>
</dl>
</li>
</ul>
<a id="mergeDelayError(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeDelayError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeDelayError&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;other)</pre>
<div class="block">Merges this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, and delays error notification until
 all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate.
 <p>
 Use <a href="#merge(java.lang.Iterable)"><code>merge(Iterable)</code></a> if any error should immediately terminate the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 This method provides a means to merge multiple asynchronous sources, delays throwing in the presence of any
 errors, and in sequential programming is similar to:
 <pre><code>
     ExecutorService e = ...;
     List&lt;Future&lt;Void&gt;&gt; futures = ...;
     futures.add(e.submit(() -&gt; resultOfThisCompletable()));
     for (Completable c : other) {
         futures.add(e.submit(() -&gt; resultOfCompletable(c));
     }
     Throwable overallCause = null;
     // This is an approximation, this operator does not provide any ordering guarantees for the results.
     for (Future&lt;Void&gt; future : futures) {
         try {
             f.get();
         } catch (Throwable cause) {
             if (overallCause != null) {
                 overallCause = cause;
             }
         }
     }
     if (overallCause != null) {
         throw overallCause;
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s to merge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates after <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and all <code>other</code>
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s. If all involved <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate successfully then the return value will
 terminate successfully. If any <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates in an error, then the return value will also
 terminate in an error.</dd>
</dl>
</li>
</ul>
<a id="retry(io.servicetalk.concurrent.api.BiIntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;retry&#8203;(<a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api">BiIntPredicate</a>&lt;java.lang.Throwable&gt;&nbsp;shouldRetry)</pre>
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> if an error is emitted and the passed <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> returns
 <code>true</code>.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>retryWhen((i, cause) -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to retry an operation under certain failure conditions and in sequential programming
 is similar to:
 <pre><code>
     public T execute() {
         return execute(0);
     }

     private T execute(int attempts) {
         try {
             resultOfThisCompletable();
         } catch (Throwable cause) {
             if (shouldRetry.apply(attempts + 1, cause)) {
                 return execute(attempts + 1);
             } else {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRetry</code> - <a href="BiIntPredicate.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntPredicate</code></a> that given the retry count and the most recent <code>Throwable</code>
 emitted from this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> determines if the operation should be retried.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that completes with this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or re-subscribes if an error is
 emitted and if the passed <code>BiPredicate</code> returned <code>true</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="retryWhen(io.servicetalk.concurrent.api.BiIntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retryWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;retryWhen&#8203;(<a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api">BiIntFunction</a>&lt;java.lang.Throwable,&#8203;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;retryWhen)</pre>
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> if an error is emitted and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the
 supplied <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates with that error.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>retryWhen((i, cause) -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to retry an operation under certain failure conditions in an asynchronous fashion
 and in sequential programming is similar to:
 <pre><code>
     public T execute() {
         return execute(0);
     }

     private T execute(int attempts) {
         try {
             resultOfThisCompletable();
         } catch (Throwable cause) {
             try {
                 shouldRetry.apply(attempts + 1, cause); // Either throws or completes normally
                 execute(attempts + 1);
             } catch (Throwable ignored) {
                 throw cause;
             }
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>retryWhen</code> - <a href="BiIntFunction.html" title="interface in io.servicetalk.concurrent.api"><code>BiIntFunction</code></a> that given the retry count and the most recent <code>Throwable</code> emitted
 from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, that
 error is emitted from the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, otherwise, original <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is re-subscribed
 when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that completes with this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or re-subscribes if an error is
 emitted and <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by <code>BiFunction</code> completes successfully.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeat(java.util.function.IntPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Void&gt;&nbsp;repeat&#8203;(java.util.function.IntPredicate&nbsp;shouldRepeat)</pre>
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> when it completes and the passed <code>IntPredicate</code> returns
 <code>true</code>.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>repeatWhen(i -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to repeat an operation multiple times and in sequential programming is similar to:
 <pre><code>
     int i = 0;
     do {
         resultOfThisCompletable();
     } while (shouldRepeat.test(++i));
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>shouldRepeat</code> - <code>IntPredicate</code> that given the repeat count determines if the operation should be
 repeated</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that emits the value returned by the passed <code>Supplier</code> everytime this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX repeat operator.</a></dd>
</dl>
</li>
</ul>
<a id="repeatWhen(java.util.function.IntFunction)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeatWhen</h4>
<pre class="methodSignature">public final&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;java.lang.Void&gt;&nbsp;repeatWhen&#8203;(java.util.function.IntFunction&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;repeatWhen)</pre>
<div class="block">Re-subscribes to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> when it completes and the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> returned by the supplied
 <code>IntFunction</code> completes successfully. If the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error, the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error.
 <pre>
 This method may result in a <code>StackOverflowError</code> if too many consecutive calls are made. This can be
 avoided by trampolining the call stack onto an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. For example:
   <code>repeatWhen(i -&gt; i % 10 == 0 ? executor.submit(() -&gt; { }) : Completable.completed())</code>
 </pre>
 This method provides a means to repeat an operation multiple times when in an asynchronous fashion and in
 sequential programming is similar to:
 <pre><code>
     int i = 0;
     while (true) {
         resultOfThisCompletable();
         try {
             repeatWhen.apply(++i); // Either throws or completes normally
         } catch (Throwable cause) {
             break;
         }
     }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>repeatWhen</code> - <code>IntFunction</code> that given the repeat count returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 If this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> emits an error repeat is terminated, otherwise, original <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is
 re-subscribed when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> completes.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that completes after all re-subscriptions completes.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX retry operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;beforeOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>before</strong> <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeOnComplete(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;beforeOnComplete&#8203;(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>before</strong> <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>
 is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  resultOfThisCompletable();
  onComplete.run();
  nextOperation();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onComplete</code> - Invoked <strong>before</strong> <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;beforeOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>before</strong>
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    resultOfThisCompletable();
  } catch (Throwable cause) {
      onError.accept(cause);
      nextOperation(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>before</strong> <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;beforeCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>before</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="beforeFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;beforeFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>before</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <pre><code>
  try {
      resultOfThisCompletable();
  } finally {
      doFinally.run();
      nextOperation(); // Maybe notifying of cancellation, or termination
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;beforeFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>beforeFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>before</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      resultOfThisCompletable();
  } catch(Throwable t) {
      doFinally.onError(t);
      nextOperation(); // Maybe notifying of cancellation, or termination
      return;
  }
  doFinally.onComplete();
  nextOperation(); // Maybe notifying of cancellation, or termination
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="beforeSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>beforeSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;beforeSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to
 subscribe and invokes all the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> on each call to subscribe and invokes all the
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>before</strong> the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;afterOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked <strong>after</strong> <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="whenOnSubscribe(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenOnSubscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;whenOnSubscribe&#8203;(java.util.function.Consumer&lt;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&gt;&nbsp;onSubscribe)</pre>
<div class="block">Invokes the <code>onSubscribe</code> <code>Consumer</code> argument when
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 The order in which <code>onSubscribe</code> will be invoked relative to
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is undefined. If you need strict ordering see
 <a href="#beforeOnSubscribe(java.util.function.Consumer)"><code>beforeOnSubscribe(Consumer)</code></a> and <a href="#afterOnSubscribe(java.util.function.Consumer)"><code>afterOnSubscribe(Consumer)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onSubscribe</code> - Invoked when <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#beforeOnSubscribe(java.util.function.Consumer)"><code>beforeOnSubscribe(Consumer)</code></a>, 
<a href="#afterOnSubscribe(java.util.function.Consumer)"><code>afterOnSubscribe(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a id="afterOnComplete(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnComplete</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;afterOnComplete&#8203;(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Invokes the <code>onComplete</code> <code>Runnable</code> argument <strong>after</strong> <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a>
 is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  resultOfThisCompletable();
  nextOperation();
  onComplete.run();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onComplete</code> - Invoked <strong>after</strong> <a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterOnError(java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterOnError</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;afterOnError&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Invokes the <code>onError</code> <code>Consumer</code> argument <strong>after</strong>
 <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
    resultOfThisCompletable();
  } catch (Throwable cause) {
      nextOperation(cause);
      onError.accept(cause);
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onError</code> - Invoked <strong>after</strong> <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> is called for
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterCancel(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterCancel</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;afterCancel&#8203;(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Invokes the <code>onCancel</code> <code>Runnable</code> argument <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is
 called for Subscriptions of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onCancel</code> - Invoked <strong>after</strong> <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> is called for Subscriptions of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="afterFinally(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;afterFinally&#8203;(java.lang.Runnable&nbsp;doFinally)</pre>
<div class="block">Invokes the <code>whenFinally</code> <code>Runnable</code> argument <strong>after</strong> any of the following terminal
 methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      resultOfThisCompletable();
  } finally {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - Invoked <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterFinally(io.servicetalk.concurrent.api.TerminalSignalConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterFinally</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;afterFinally&#8203;(<a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api">TerminalSignalConsumer</a>&nbsp;doFinally)</pre>
<div class="block">Invokes the corresponding method on <code>afterFinally</code> <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> argument
 <strong>after</strong> any of the following terminal methods are called:
 <ul>
     <li><a href="../CompletableSource.Subscriber.html#onComplete()"><code>CompletableSource.Subscriber.onComplete()</code></a> - invokes <a href="TerminalSignalConsumer.html#onComplete()"><code>TerminalSignalConsumer.onComplete()</code></a></li>
     <li><a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a> - invokes <a href="TerminalSignalConsumer.html#onError(java.lang.Throwable)"><code>TerminalSignalConsumer.onError(Throwable)</code></a></li>
     <li><a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> - invokes <a href="TerminalSignalConsumer.html#cancel()"><code>TerminalSignalConsumer.cancel()</code></a></li>
 </ul>
 for Subscriptions/<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
  try {
      resultOfThisCompletable();
  } catch(Throwable t) {
      nextOperation(); // Maybe notifying of cancellation, or termination
      doFinally.onError(t);
      return;
  }
  nextOperation(); // Maybe notifying of cancellation, or termination
  doFinally.onComplete();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doFinally</code> - For each subscribe of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, at most one method of this
 <a href="TerminalSignalConsumer.html" title="interface in io.servicetalk.concurrent.api"><code>TerminalSignalConsumer</code></a> will be invoked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/do.html">ReactiveX do operator.</a></dd>
</dl>
</li>
</ul>
<a id="afterSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>afterSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;afterSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) on each call to
 subscribe and invokes all the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> on each call to subscribe and invokes all the
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>after</strong> the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="whenSubscriber(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whenSubscriber</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;whenSubscriber&#8203;(java.util.function.Supplier&lt;? extends <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&gt;&nbsp;subscriberSupplier)</pre>
<div class="block">Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> (via the <code>subscriberSupplier</code> argument) for each new subscribe and
 invokes methods on that <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> when the corresponding methods are called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of
 the returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriberSupplier</code> - Creates a new <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> for each new subscribe and invokes methods on that
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> when the corresponding methods are called for <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>s of the returned
 <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods <strong>MUST NOT</strong> throw.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="liftSync(io.servicetalk.concurrent.api.CompletableOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftSync</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;liftSync&#8203;(<a href="CompletableOperator.html" title="interface in io.servicetalk.concurrent.api">CompletableOperator</a>&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which will wrap the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> using the provided <code>operator</code> argument
 before subscribing to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <pre><code>
     Completable&lt;X&gt; pub = ...;
     pub.map(..) // A
        .liftSync(original -&gt; modified)
        .afterFinally(..) // B
 </code></pre>
 The <code>original -&gt; modified</code> "operator" <strong>MUST</strong> be "synchronous" in that it does not interact
 with the original <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> from outside the modified <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> or <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a>
 threads. That is to say this operator will not impact the <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> constraints already in place between
 <i>A</i> and <i>B</i> above. If you need asynchronous behavior, or are unsure, see
 <a href="#liftAsync(io.servicetalk.concurrent.api.CompletableOperator)"><code>liftAsync(CompletableOperator)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> to this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and the return is the "modified" <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> before subscribing to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftAsync(io.servicetalk.concurrent.api.CompletableOperator)"><code>liftAsync(CompletableOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="liftAsync(io.servicetalk.concurrent.api.CompletableOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liftAsync</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;liftAsync&#8203;(<a href="CompletableOperator.html" title="interface in io.servicetalk.concurrent.api">CompletableOperator</a>&nbsp;operator)</pre>
<div class="block"><strong>This method requires advanced knowledge of building operators. Before using this method please attempt
 to compose existing operator(s) to satisfy your use case.</strong>
 <p>
 Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which will wrap the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> using the provided <code>operator</code> argument
 before subscribing to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <pre><code>
     Publisher&lt;X&gt; pub = ...;
     pub.map(..) // A
        .liftAsync(original -&gt; modified)
        .afterFinally(..) // B
 </code></pre>

 The <code>original -&gt; modified</code> "operator" MAY be "asynchronous" in that it may interact with the original
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> from outside the modified <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> or <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> threads. More
 specifically:
 <ul>
  <li>all of the <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> invocations going "downstream" (i.e. from <i>A</i> to <i>B</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
  <li>all of the <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> invocations going "upstream" (i.e. from <i>B</i> to <i>A</i> above) MAY be
  offloaded via an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a></li>
 </ul>
 This behavior exists to prevent blocking code negatively impacting the thread that powers the upstream source of
 data (e.g. an EventLoop).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>operator</code> - The custom operator logic. The input is the "original" <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> to this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and the return is the "modified" <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> that provides custom operator business
 logic.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that when subscribed, the <code>operator</code> argument will be used to wrap the
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> before subscribing to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#liftSync(io.servicetalk.concurrent.api.CompletableOperator)"><code>liftSync(CompletableOperator)</code></a></dd>
</dl>
</li>
</ul>
<a id="publishOn(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;publishOn&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>
 methods.
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. Only subsequent operations, if any, added in this execution chain will use this
 <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. If such an override is required, <a href="#publishOnOverride(io.servicetalk.concurrent.api.Executor)"><code>publishOnOverride(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods on the
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishOnOverride(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOnOverride</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;publishOnOverride&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This method will be removed in a future release. Consider switching to
 <a href="#publishOn(io.servicetalk.concurrent.api.Executor)"><code>publishOn(Executor)</code></a> and/or using <a href="../Executor.html#execute(java.lang.Runnable)"><code>Executor.execute(Runnable)</code></a> for offloading.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>
 methods.
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 That is to say preceding and subsequent operations for this execution chain will use this <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>.
 If such an override is not required, <a href="#publishOn(io.servicetalk.concurrent.api.Executor)"><code>publishOn(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>, <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> both for the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> as well as <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeOn(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;subscribeOn&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. Only subsequent operations, if any, added in this execution chain will use this
 <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. If such an override is required, <a href="#subscribeOnOverride(io.servicetalk.concurrent.api.Executor)"><code>subscribeOnOverride(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeOnOverride(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOnOverride</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;subscribeOnOverride&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This method will be removed in a future release. Consider switching to
 <a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)"><code>subscribeOn(Executor)</code></a> and/or using <a href="../Executor.html#execute(java.lang.Runnable)"><code>Executor.execute(Runnable)</code></a> for offloading.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> method.</li>
 </ul>
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 That is to say preceding and subsequent operations for this execution chain will use this <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>.
 If such an override is not required, <a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)"><code>subscribeOn(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> both for the returned
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> as well as <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishAndSubscribeOn</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;publishAndSubscribeOn&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This operator has been deprecated because of upcoming behavior changes in how offloading via
 operators is done. Originally offloading for subscribe/subscription was applied at the "bottom" of chain
 (logically the last operator in the chain closest to the subscriber), and offloading for subscriber was applied
 at the "top" of the operator chain (logically the first operator in the chain after the async source). The
 current offloading doesn't respect the order in which the operators are applied, the offloading is the same
 regardless of where the operators are placed in the chain. However, this behavior will soon change to instead
 respect operator placement order and apply offloading exactly where the offloading operators are applied in the
 chain. This change in behavior means that it no longer makes sense to fuse the offloading of publish and
 subscribe as the location of the operators in the chain will now be significant. Publish and subscribe
 offloading, when required, will typically be placed in different locations. Use separate, appropriately placed,
 <a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)"><code>subscribeOn(Executor)</code></a> and <a href="#publishOn(io.servicetalk.concurrent.api.Executor)"><code>publishOn(Executor)</code></a> operators instead.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods.</li>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> method.</li>
 </ul>
 This method does <strong>not</strong> override preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code>
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. Only subsequent operations, if any, added in this execution chain will use this
 <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>. If such an override is required, <a href="#publishAndSubscribeOnOverride(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOnOverride(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>, <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a>.</dd>
</dl>
</li>
</ul>
<a id="publishAndSubscribeOnOverride(io.servicetalk.concurrent.api.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishAndSubscribeOnOverride</h4>
<pre class="methodSignature">@Deprecated
public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;publishAndSubscribeOnOverride&#8203;(<a href="Executor.html" title="interface in io.servicetalk.concurrent.api">Executor</a>&nbsp;executor)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">This method will be removed in a future release. Consider switching to
 <a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOn(Executor)</code></a> and/or using <a href="../Executor.html#execute(java.lang.Runnable)"><code>Executor.execute(Runnable)</code></a> for offloading.</div>
</div>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke the following methods:
 <ul>
     <li>All <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> methods.</li>
     <li>All <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> methods.</li>
     <li>The <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> method.</li>
 </ul>
 This method overrides preceding <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>s, if any, specified for <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 That is to say preceding and subsequent operations for this execution chain will use this <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a>.
 If such an override is not required, <a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOn(Executor)</code></a> can be used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>executor</code> - <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to use.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will use the passed <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> to invoke all methods of
 <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>, <a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> and <a href="#handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>handleSubscribe(CompletableSource.Subscriber)</code></a> both for the
 returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> as well as <code>this</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeShareContext()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeShareContext</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;subscribeShareContext()</pre>
<div class="block">Signifies that when the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed to, the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> will be shared
 instead of making a <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a>.
 <p>
 This operator only impacts behavior if the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is subscribed directly after this
 operator, that means this must be the "last operator" in the chain for this to have an impact.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that will share the <a href="AsyncContext.html" title="class in io.servicetalk.concurrent.api"><code>AsyncContext</code></a> instead of making a
 <a href="../../context/api/ContextMap.html#copy()"><code>copy</code></a> when subscribed to.</dd>
</dl>
</li>
</ul>
<a id="ambWith(io.servicetalk.concurrent.api.Completable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ambWith</h4>
<pre class="methodSignature">public final&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;ambWith&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;other)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of either this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or the passed <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, whichever terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator will pick the first result from either of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>other</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with which the result of this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> is to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of either this
 <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> or the passed <code>other</code> <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>, whichever terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="toPublisher()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toPublisher</h4>
<pre class="methodSignature">public final&nbsp;&lt;T&gt;&nbsp;<a href="Publisher.html" title="class in io.servicetalk.concurrent.api">Publisher</a>&lt;T&gt;&nbsp;toPublisher()</pre>
<div class="block">Converts this <code>Completable</code> to a <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.
 <p>
 No <a href="../PublisherSource.Subscriber.html#onNext(T)"><code>PublisherSource.Subscriber.onNext(Object)</code></a> signals will be delivered to the
 returned <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>. Only terminal signals will be delivered. If you need more control you should consider
 using <a href="#concat(io.servicetalk.concurrent.api.Publisher)"><code>concat(Publisher)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The value type of the resulting <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Publisher.html" title="class in io.servicetalk.concurrent.api"><code>Publisher</code></a> that mirrors the terminal signal from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="toSingle()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toSingle</h4>
<pre class="methodSignature">public final&nbsp;<a href="Single.html" title="class in io.servicetalk.concurrent.api">Single</a>&lt;java.lang.Void&gt;&nbsp;toSingle()</pre>
<div class="block">Converts this <code>Completable</code> to a <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> that mirrors the terminal signal from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="toCompletionStage()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toCompletionStage</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.CompletionStage&lt;java.lang.Void&gt;&nbsp;toCompletionStage()</pre>
<div class="block">Converts this <code>Completable</code> to a <code>CompletionStage</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>CompletionStage</code> that mirrors the terminal signal from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="toFuture()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toFuture</h4>
<pre class="methodSignature">public final&nbsp;java.util.concurrent.Future&lt;java.lang.Void&gt;&nbsp;toFuture()</pre>
<div class="block">Converts this <code>Completable</code> to a <code>Future</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <code>Future</code> that mirrors the terminal signal from this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribeInternal(io.servicetalk.concurrent.CompletableSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeInternal</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;subscribeInternal&#8203;(<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&nbsp;subscriber)</pre>
<div class="block">A internal subscribe method similar to <a href="../CompletableSource.html#subscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>CompletableSource.subscribe(Subscriber)</code></a> which can be used by
 different implementations to subscribe.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a> to subscribe for the result.</dd>
</dl>
</li>
</ul>
<a id="subscribe()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&nbsp;subscribe()</pre>
<div class="block">Subscribe to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and log any <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> used to invoke <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> on the parameter of
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> for this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="subscribe(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre class="methodSignature">public final&nbsp;<a href="../Cancellable.html" title="interface in io.servicetalk.concurrent">Cancellable</a>&nbsp;subscribe&#8203;(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Subscribe to this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> and log any <a href="../CompletableSource.Subscriber.html#onError(java.lang.Throwable)"><code>CompletableSource.Subscriber.onError(Throwable)</code></a>. Passed <code>Runnable</code>
 is invoked when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onComplete</code> - <code>Runnable</code> to invoke when this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminates successfully.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="../Cancellable.html" title="interface in io.servicetalk.concurrent"><code>Cancellable</code></a> used to invoke <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> on the parameter of
 <a href="../CompletableSource.Subscriber.html#onSubscribe(io.servicetalk.concurrent.Cancellable)"><code>CompletableSource.Subscriber.onSubscribe(Cancellable)</code></a> for this <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
</dl>
</li>
</ul>
<a id="handleSubscribe(io.servicetalk.concurrent.CompletableSource.Subscriber)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handleSubscribe</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;handleSubscribe&#8203;(<a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent">CompletableSource.Subscriber</a>&nbsp;subscriber)</pre>
<div class="block">Handles a subscriber to this <code>Completable</code>.
 <p>
 This method is invoked internally by <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> for every call to the
 <a href="#subscribeInternal(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>subscribeInternal(CompletableSource.Subscriber)</code></a> method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subscriber</code> - the subscriber.</dd>
</dl>
</li>
</ul>
<a id="completed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completed</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;completed()</pre>
<div class="block">Creates a realized completed <code>Completable</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <code>Completable</code>.</dd>
</dl>
</li>
</ul>
<a id="fromRunnable(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromRunnable</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;fromRunnable&#8203;(java.lang.Runnable&nbsp;runnable)</pre>
<div class="block">Creates a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> which when subscribed will invoke <code>Runnable.run()</code> on the passed
 <code>Runnable</code> and emit the value returned by that invocation from the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>. Any error
 emitted by the <code>Runnable</code> will terminate the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> with the same error.
 <p>
 Blocking inside <code>Runnable.run()</code> will in turn block the subscribe call to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 If this behavior is undesirable then the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> should be offloaded using one of the
 operators that offloads the subscribe call (eg: <a href="#subscribeOn(io.servicetalk.concurrent.api.Executor)"><code>subscribeOn(Executor)</code></a>,
 <a href="#publishAndSubscribeOn(io.servicetalk.concurrent.api.Executor)"><code>publishAndSubscribeOn(Executor)</code></a>).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>runnable</code> - <code>Runnable</code> which is invoked before completion.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <code>Completable</code>.</dd>
</dl>
</li>
</ul>
<a id="failed(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>failed</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;failed&#8203;(java.lang.Throwable&nbsp;cause)</pre>
<div class="block">Creates a realized failed <code>Completable</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cause</code> - error that the returned <code>Completable</code> completes with.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <code>Completable</code>.</dd>
</dl>
</li>
</ul>
<a id="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;never()</pre>
<div class="block">Creates a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that never terminates.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <code>Completable</code>.</dd>
</dl>
</li>
</ul>
<a id="defer(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defer</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;defer&#8203;(java.util.function.Supplier&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completableSupplier)</pre>
<div class="block">Defer creation of a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> till it is subscribed to.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completableSupplier</code> - <code>Supplier</code> to create a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> for every call to
 <a href="#subscribeInternal(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>subscribeInternal(CompletableSource.Subscriber)</code></a> to the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> using <code>completableFactory</code>
 for every call to <a href="#subscribeInternal(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>subscribeInternal(CompletableSource.Subscriber)</code></a> and forwards
 the termination signal from the newly created <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> to its <a href="../CompletableSource.Subscriber.html" title="interface in io.servicetalk.concurrent"><code>CompletableSource.Subscriber</code></a>.</dd>
</dl>
</li>
</ul>
<a id="fromFuture(java.util.concurrent.Future)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromFuture</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;fromFuture&#8203;(java.util.concurrent.Future&lt;?&gt;&nbsp;future)</pre>
<div class="block">Convert from a <code>Future</code> to a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> via <code>Future.get()</code>.
 <p>
 Note that because <code>Future</code> only presents blocking APIs to extract the result, so the process of getting the
 results will block. The caller of <a href="#subscribeInternal(io.servicetalk.concurrent.CompletableSource.Subscriber)"><code>subscribeInternal(CompletableSource.Subscriber)</code></a> is responsible for
 offloading if necessary, and also offloading if <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> will be called if this operation may
 block.
 <p>
 To apply a timeout see <a href="#timeout(long,java.util.concurrent.TimeUnit)"><code>timeout(long, TimeUnit)</code></a> and related methods.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>future</code> - The <code>Future</code> to convert.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that derives results from <code>Future</code>.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#timeout(long,java.util.concurrent.TimeUnit)"><code>timeout(long, TimeUnit)</code></a></dd>
</dl>
</li>
</ul>
<a id="fromStage(java.util.concurrent.CompletionStage)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromStage</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;fromStage&#8203;(java.util.concurrent.CompletionStage&lt;?&gt;&nbsp;stage)</pre>
<div class="block">Convert from a <code>CompletionStage</code> to a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>.
 <p>
 A best effort is made to propagate <a href="../Cancellable.html#cancel()"><code>Cancellable.cancel()</code></a> to the <code>CompletionStage</code>. Cancellation for
 <code>CompletionStage</code> implementations will result in exceptional completion and invoke user
 callbacks. If there is any blocking code involved in the cancellation process (including invoking user callbacks)
 you should investigate if using an <a href="Executor.html" title="interface in io.servicetalk.concurrent.api"><code>Executor</code></a> is appropriate.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stage</code> - The <code>CompletionStage</code> to convert.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that derives results from <code>CompletionStage</code>.</dd>
</dl>
</li>
</ul>
<a id="mergeAll(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAll</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAll&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 This will actively subscribe to a default number of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s concurrently, in order to alter the
 defaults, <a href="#mergeAll(java.lang.Iterable,int)"><code>mergeAll(Iterable, int)</code></a>.
 <p>
 If any of the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate with an error, returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will immediately
 terminate with that error. In such a case, any in-progress <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s will be cancelled. In order to
 delay error termination use <a href="#mergeAllDelayError(java.lang.Iterable)"><code>mergeAllDelayError(Iterable)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <code>Iterable</code> of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="mergeAll(io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAll</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAll&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 This will actively subscribe to a default number of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s concurrently, in order to alter the
 defaults, <a href="#mergeAll(int,io.servicetalk.concurrent.api.Completable...)"><code>mergeAll(int, Completable...)</code></a> should be used.
 <p>
 If any of the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate with an error, returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will immediately
 terminate with that error. In such a case, any in-progress <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s will be cancelled.
  In order to delay error termination use <a href="#mergeAllDelayError(io.servicetalk.concurrent.api.Completable...)"><code>mergeAllDelayError(Completable...)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="mergeAll(java.lang.Iterable,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAll</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAll&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables,
                                   int&nbsp;maxConcurrency)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 If any of the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate with an error, returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will immediately
 terminate with that error. In such a case, any in-progress <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s will be cancelled. In order to
 delay error termination use <a href="#mergeAllDelayError(java.lang.Iterable,int)"><code>mergeAllDelayError(Iterable, int)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <code>Iterable</code> of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s that will be active at any point in time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="mergeAll(int,io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAll</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAll&#8203;(int&nbsp;maxConcurrency,
                                   <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 If any of the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate with an error, returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will immediately
 terminate with that error. In such a case, any in-progress <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s will be cancelled.
  In order to delay error termination use <a href="#mergeAllDelayError(int,io.servicetalk.concurrent.api.Completable...)"><code>mergeAllDelayError(int, Completable...)</code></a>.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
          ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s that will be active at any point in time.</dd>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="mergeAllDelayError(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAllDelayError</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAllDelayError&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 This will actively subscribe to a default number of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s concurrently, in order to alter the
 defaults, <a href="#mergeAllDelayError(java.lang.Iterable,int)"><code>mergeAllDelayError(Iterable, int)</code></a> should be used.
 <p>
 If any of the <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s terminate with an error, returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> will wait for
 termination till all the other <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have been subscribed and terminated. If it is expected for
 the returned <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> to terminate on the first failing <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>,
 <a href="#mergeAll(java.lang.Iterable)"><code>mergeAll(Iterable)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                 ft.get();
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <code>Iterable</code> of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="mergeAllDelayError(io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAllDelayError</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAllDelayError&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 This will actively subscribe to a limited number of <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s concurrently, in order to alter the defaults,
 <a href="#mergeAll(int,io.servicetalk.concurrent.api.Completable...)"><code>mergeAll(int, Completable...)</code></a> should be used.
 <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#mergeAll(io.servicetalk.concurrent.api.Completable...)"><code>mergeAll(Completable...)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                 ft.get();
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="mergeAllDelayError(java.lang.Iterable,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAllDelayError</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAllDelayError&#8203;(java.lang.Iterable&lt;? extends <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables,
                                             int&nbsp;maxConcurrency)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#mergeAll(java.lang.Iterable,int)"><code>mergeAll(Iterable, int)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                 ft.get();
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <code>Iterable</code> of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s that will be active at any point in time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="mergeAllDelayError(int,io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeAllDelayError</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;mergeAllDelayError&#8203;(int&nbsp;maxConcurrency,
                                             <a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</pre>
<div class="block">Returns a <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates when all the passed <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> terminate.
 <p>
 If any of the <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s terminate with an error, returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a> will wait for termination till all
 the other <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>s have been subscribed and terminated. If it is expected for the returned <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>
 to terminate on the first failing <a href="Single.html" title="class in io.servicetalk.concurrent.api"><code>Single</code></a>, <a href="#mergeAll(java.lang.Iterable,int)"><code>mergeAll(Iterable, int)</code></a> should be used.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      List&lt;Throwable&gt; errors = ...;  // assume this is thread safe
      for (Future&lt;Void&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator does not provide any ordering guarantees for the results.
             try {
                 ft.get();
             } catch(Throwable t) {
                errors.add(t);
             }
      }
     if (errors.isEmpty()) {
         return;
     }
     createAndThrowACompositeException(errors);
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>maxConcurrency</code> - Maximum number of <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s that will be active at any point in time.</dd>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s, results of which are to be collected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates successfully if all the provided <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s have
 terminated successfully or any one of them has terminated with a failure.</dd>
</dl>
</li>
</ul>
<a id="amb(io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>amb</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;amb&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="amb(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>amb</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;amb&#8203;(java.lang.Iterable&lt;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.
 that result.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="anyOf(io.servicetalk.concurrent.api.Completable...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyOf</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;anyOf&#8203;(<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>...&nbsp;completables)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
<a id="anyOf(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>anyOf</h4>
<pre class="methodSignature">public static&nbsp;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&nbsp;anyOf&#8203;(java.lang.Iterable&lt;<a href="Completable.html" title="class in io.servicetalk.concurrent.api">Completable</a>&gt;&nbsp;completables)</pre>
<div class="block">Creates a new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.
 <p>
 From a sequential programming point of view this method is roughly equivalent to the following:
 <pre><code>
      for (Future&lt;T&gt; ft: futures) { // Provided Futures (analogous to the Completables here)
          // This is an approximation, this operator will pick the first result from any of the futures.
          return ft.get();
      }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>completables</code> - <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a>s the result of which are to be ambiguated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new <a href="Completable.html" title="class in io.servicetalk.concurrent.api"><code>Completable</code></a> that terminates with the result (either success or error) of whichever amongst
 the passed <code>completables</code> that terminates first.
 that result.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX amb operator.</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
